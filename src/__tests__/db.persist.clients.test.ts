/**
 * Minimal persistence tests for Dexie updating/creating hooks
 * Verifies that the core fix for db.ts hooks works correctly
 */

import { describe, it, expect, beforeEach, afterEach } from 'vitest';
import { db } from '../data/db';
import { cryptoManager } from '../data/crypto';
import { getEncryptionMode } from '../utils/env';
import type { Client } from '../domain/models';

describe('DB Persistence - Clients', () => {
  beforeEach(async () => {
    // Ensure crypto key is available
    try {
      await cryptoManager.getActiveKey();
    } catch {
      // In dev-enc mode, key should be auto-generated
      if (getEncryptionMode() === 'dev-enc') {
        // Key will be auto-generated by devKey utility
      }
    }
    
    // Clear test data
    await db.clients.where('id').startsWith('test-persist-').delete();
  });

  afterEach(async () => {
    // Cleanup test data
    await db.clients.where('id').startsWith('test-persist-').delete();
  });

  describe('creating hook', () => {
    it('should persist new client correctly', async () => {
      const testClient: Client = {
        id: 'test-persist-create-1',
        firstName: 'Max',
        lastName: 'Mustermann',
        status: 'offen',
        priority: 'normal',
        contactCount: 0,
        contactLog: [],
        isArchived: false
      };

      // Act: Create client
      await db.clients.put(testClient);

      // Assert: Client should be retrievable and correctly decrypted
      const retrieved = await db.clients.get('test-persist-create-1');
      
      expect(retrieved).toBeDefined();
      expect(retrieved.id).toBe('test-persist-create-1');
      expect(retrieved.firstName).toBe('Max');
      expect(retrieved.lastName).toBe('Mustermann');
      expect(retrieved.status).toBe('offen');
      expect(retrieved.priority).toBe('normal');
      expect(retrieved.contactCount).toBe(0);
      expect(retrieved.isArchived).toBe(false);
    });
  });

  describe('updating hook', () => {
    it('should persist multi-field updates correctly', async () => {
      // Arrange: Create initial client
      const initialClient: Client = {
        id: 'test-persist-update-1',
        firstName: 'Anna',
        lastName: 'Schmidt',
        status: 'offen',
        priority: 'normal',
        contactCount: 0,
        contactLog: [],
        isArchived: false,
        isPinned: false,
        assignedTo: undefined,
        followUp: undefined
      };

      await db.clients.put(initialClient);
      
      // Verify initial state
      const initial = await db.clients.get('test-persist-update-1');
      expect(initial.status).toBe('offen');
      expect(initial.isPinned).toBe(false);
      const initialCreatedAt = initial.createdAt;

      // Act: Perform multi-field update (simulates MutationService.applyPatch)
      const current = await db.clients.get('test-persist-update-1');
      const nextPlain = {
        ...current,
        isPinned: true,
        priority: 'hoch',
        status: 'inBearbeitung',
        contactCount: 3,
        assignedTo: 'user-123',
        followUp: '2024-12-25T10:00:00Z'
      };
      
      await db.clients.put(nextPlain);

      // Assert: All changes should be persisted
      const updated = await db.clients.get('test-persist-update-1');
      
      expect(updated).toBeDefined();
      expect(updated.id).toBe('test-persist-update-1');
      
      // Verify all updated fields
      expect(updated.isPinned).toBe(true);
      expect(updated.priority).toBe('hoch');
      expect(updated.status).toBe('inBearbeitung');
      expect(updated.contactCount).toBe(3);
      expect(updated.assignedTo).toBe('user-123');
      expect(updated.followUp).toBe('2024-12-25T10:00:00Z');
      
      // Verify unchanged fields are preserved
      expect(updated.firstName).toBe('Anna');
      expect(updated.lastName).toBe('Schmidt');
      expect(updated.isArchived).toBe(false);
      
      // Verify meta fields
      expect(updated.createdAt).toBe(initialCreatedAt); // Should be preserved
      expect(updated.updatedAt).toBeDefined();
      expect(updated.updatedAt).not.toBe(initialCreatedAt); // Should be newer
    });

    it('should handle pin toggle persistence', async () => {
      // Arrange: Create unpinned client
      const client: Client = {
        id: 'test-persist-pin-1',
        firstName: 'Thomas',
        lastName: 'Weber',
        status: 'offen',
        priority: 'normal',
        contactCount: 0,
        contactLog: [],
        isArchived: false,
        isPinned: false
      };

      await db.clients.put(client);

      // Act: Pin client
      const current = await db.clients.get('test-persist-pin-1');
      const pinned = {
        ...current,
        isPinned: true,
        pinnedAt: new Date().toISOString()
      };
      
      await db.clients.put(pinned);

      // Assert: Pin state should be persisted
      const retrieved = await db.clients.get('test-persist-pin-1');
      expect(retrieved.isPinned).toBe(true);
      expect(retrieved.pinnedAt).toBeDefined();

      // Act: Unpin client
      const currentPinned = await db.clients.get('test-persist-pin-1');
      const unpinned = {
        ...currentPinned,
        isPinned: false,
        pinnedAt: undefined
      };
      
      await db.clients.put(unpinned);

      // Assert: Unpin state should be persisted
      const retrievedUnpinned = await db.clients.get('test-persist-pin-1');
      expect(retrievedUnpinned.isPinned).toBe(false);
      expect(retrievedUnpinned.pinnedAt).toBeUndefined();
    });

    it('should handle priority cycling persistence', async () => {
      // Arrange: Create client with normal priority
      const client: Client = {
        id: 'test-persist-priority-1',
        firstName: 'Maria',
        lastName: 'Fischer',
        status: 'offen',
        priority: 'normal',
        contactCount: 0,
        contactLog: [],
        isArchived: false
      };

      await db.clients.put(client);

      // Act: Cycle through priorities
      const priorities = ['niedrig', 'normal', 'hoch', 'dringend'] as const;
      
      for (const priority of priorities) {
        const current = await db.clients.get('test-persist-priority-1');
        const updated = {
          ...current,
          priority
        };
        
        await db.clients.put(updated);

        // Assert: Each priority change should be persisted
        const retrieved = await db.clients.get('test-persist-priority-1');
        expect(retrieved.priority).toBe(priority);
      }
    });

    it('should handle contact count increments persistence', async () => {
      // Arrange: Create client with zero contacts
      const client: Client = {
        id: 'test-persist-contact-1',
        firstName: 'Peter',
        lastName: 'Bauer',
        status: 'offen',
        priority: 'normal',
        contactCount: 0,
        contactLog: [],
        isArchived: false
      };

      await db.clients.put(client);

      // Act: Increment contact count multiple times
      for (let i = 1; i <= 5; i++) {
        const current = await db.clients.get('test-persist-contact-1');
        const updated = {
          ...current,
          contactCount: i,
          lastActivity: new Date().toISOString()
        };
        
        await db.clients.put(updated);

        // Assert: Each increment should be persisted
        const retrieved = await db.clients.get('test-persist-contact-1');
        expect(retrieved.contactCount).toBe(i);
        expect(retrieved.lastActivity).toBeDefined();
      }
    });
  });

  describe('users updating hook', () => {
    it('should persist user updates correctly', async () => {
      // Arrange: Create test user
      const testUser = {
        id: 'test-persist-user-1',
        name: 'Test User',
        role: 'editor' as const,
        active: true
      };

      await db.users.put(testUser);
      
      const initial = await db.users.get('test-persist-user-1');
      const initialCreatedAt = initial.createdAt;

      // Act: Update user
      const current = await db.users.get('test-persist-user-1');
      const updated = {
        ...current,
        name: 'Updated Test User',
        role: 'admin' as const,
        active: false
      };
      
      await db.users.put(updated);

      // Assert: Updates should be persisted
      const retrieved = await db.users.get('test-persist-user-1');
      
      expect(retrieved.name).toBe('Updated Test User');
      expect(retrieved.role).toBe('admin');
      expect(retrieved.active).toBe(false);
      
      // Meta fields
      expect(retrieved.createdAt).toBe(initialCreatedAt);
      expect(retrieved.updatedAt).toBeDefined();
      expect(retrieved.updatedAt).not.toBe(initialCreatedAt);
    });
  });

  describe('importSessions hooks', () => {
    it('should persist import session creation and updates', async () => {
      // Arrange: Create test import session
      const testSession = {
        id: 'test-persist-session-1',
        sourceId: 'test-source',
        createdAt: new Date().toISOString(),
        stats: {
          created: 5,
          updated: 2,
          archived: 1,
          deleted: 0
        }
      };

      // Act: Create session
      await db.importSessions.put(testSession);

      // Assert: Creation should work
      const created = await db.importSessions.get('test-persist-session-1');
      expect(created).toBeDefined();
      expect(created.sourceId).toBe('test-source');
      expect(created.stats.created).toBe(5);

      // Act: Update session
      const current = await db.importSessions.get('test-persist-session-1');
      const updated = {
        ...current,
        stats: {
          created: 10,
          updated: 5,
          archived: 2,
          deleted: 1
        }
      };
      
      await db.importSessions.put(updated);

      // Assert: Updates should be persisted
      const retrieved = await db.importSessions.get('test-persist-session-1');
      expect(retrieved.stats.created).toBe(10);
      expect(retrieved.stats.updated).toBe(5);
      expect(retrieved.stats.archived).toBe(2);
      expect(retrieved.stats.deleted).toBe(1);
    });
  });

  describe('envelope structure validation', () => {
    it('should store data as encrypted envelope in IndexedDB', async () => {
      const testClient: Client = {
        id: 'test-persist-envelope-1',
        firstName: 'Envelope',
        lastName: 'Test',
        status: 'offen',
        priority: 'normal',
        contactCount: 0,
        contactLog: [],
        isArchived: false
      };

      await db.clients.put(testClient);

      // Get raw stored value (before decryption hook)
      const rawStored = await db.transaction('r', [db.clients], async () => {
        return await db.clients.where('id').equals('test-persist-envelope-1').first();
      });

      // Should be an envelope structure
      expect(rawStored).toBeDefined();
      expect(rawStored.v).toBe(1); // Envelope v1
      expect(rawStored.mode).toBeDefined();
      expect(rawStored.alg).toBe('AES-256-GCM');
      expect(rawStored.ts).toBeDefined();
      
      // Index fields should be on root level
      expect(rawStored.id).toBe('test-persist-envelope-1');
      
      // Payload should be encrypted (no plain firstName/lastName on root)
      expect(rawStored.firstName).toBeUndefined();
      expect(rawStored.lastName).toBeUndefined();
    });
  });
});